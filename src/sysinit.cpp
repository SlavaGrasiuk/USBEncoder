#include "stm32f1xx.h"

/*
==================
init_clocks
==================
*/
static inline void init_clocks() {
    // Enable HSE
    RCC->CR = (RCC->CR & ~(RCC_CR_HSEON | RCC_CR_HSEBYP))| RCC_CR_HSEON;
    while(!(RCC->CR & RCC_CR_HSERDY)) ;

#if (!defined STM32F10X_LD_VL) && (!defined STM32F10X_MD_VL)
    // Enable Prefetch Buffer
    FLASH->ACR |= FLASH_ACR_PRFTBE;

    // Flash 2 wait state (if freq in 24..48 MHz range - 1WS.)
    FLASH->ACR = (FLASH->ACR & ~FLASH_ACR_LATENCY) | FLASH_ACR_LATENCY_2;
#endif

    // HCLK = SYSCLK, PCLK2 = HCLK, PCLK1 = HCLK/2
    RCC->CFGR = (RCC->CFGR & ~(RCC_CFGR_HPRE | RCC_CFGR_PPRE2 | RCC_CFGR_PPRE1 | RCC_CFGR_ADCPRE)) |
			RCC_CFGR_HPRE_DIV1 | RCC_CFGR_PPRE2_DIV1 | RCC_CFGR_PPRE1_DIV2 | RCC_CFGR_ADCPRE_DIV6;

#ifdef STM32F10X_CL
    // PLL2/3 pre-divisor: PREDIV2 = 5 (25/5 = 5 MHz)
    RCC->CFGR2 = (RCC->CFGR2 & ~RCC_CFGR2_PREDIV2) | RCC_CFGR2_PREDIV2_DIV5;
    // PLL2 multiplier: PLL2CLK = 5 * 8 = 40 MHz
    RCC->CFGR2 = (RCC->CFGR2 & ~RCC_CFGR2_PLL2MUL) | RCC_CFGR2_PLL2MUL8;

    // Enable PLL2
    RCC->CR |= RCC_CR_PLL2ON;
    while(!(RCC->CR & RCC_CR_PLL2RDY)) ;

    // PREDIV1 configuration: SRC = PLL2, DIV = 5 (8MHz)
    RCC->CFGR2 = (RCC->CFGR2 & ~(RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC)) |
                RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5;

    // PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz
    RCC->CFGR = (RCC->CFGR & ~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL | RCC_CFGR_OTGFSPRE)) |
                RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLMULL9;
#elif (defined STM32F10X_LD_VL) || (defined STM32F10X_MD_VL)
    /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */
    RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1_Div2 | RCC_CFGR_PLLMULL6);
#else    
    // PLLCLK = 8MHz * 9 = 72 MHz
    RCC->CFGR &= ~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL);
    RCC->CFGR |= (RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL9);
#endif

    // Enable PLL
    RCC->CR |= RCC_CR_PLLON;

    // Wait till PLL is ready
    while(!(RCC->CR & RCC_CR_PLLRDY));

    // Select PLL as system clock source
    RCC->CFGR = (RCC->CFGR & ~RCC_CFGR_SW) | RCC_CFGR_SW_PLL;

    // Wait till PLL is used as system clock source
    while((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}

/*
==================
_init

	called from __libc_init_array()
==================
*/
extern "C" void _init(void) {
    //Enable Bus Fault, Memory Fault, Usage Fault
    SCB->SHCSR |= (SCB_SHCSR_BUSFAULTENA | SCB_SHCSR_MEMFAULTENA | SCB_SHCSR_USGFAULTENA);

    // RCC system reset(for debug purpose)
    // Set HSION bit
    RCC->CR |= RCC_CR_HSION;
    // Reset SW[1:0], HPRE[3:0], PPRE1[2:0], PPRE2[2:0], ADCPRE[1:0] and MCO[2:0] bits

#ifndef STM32F10X_CL
    RCC->CFGR &= (uint32_t)0xF8FF0000;
#else
    RCC->CFGR &= (uint32_t)0xF0FF0000;
#endif

    // Reset HSEON, CSSON and PLLON bits
    RCC->CR &= ~(RCC_CR_HSEON | RCC_CR_CSSON | RCC_CR_PLLON);
    // Reset HSEBYP bit
    RCC->CR &= ~RCC_CR_HSEBYP;
    // Reset PLLSRC, PLLXTPRE, PLLMUL[3:0] and USBPRE bits
    RCC->CFGR &= (uint32_t)0xFF80FFFF;

#ifdef STM32F10X_CL
    // Reset PLL2ON and PLL3ON bits
    RCC->CR &= (uint32_t)0xEBFFFFFF;

    // Disable all interrupts and clear pending bits
    RCC->CIR = 0x00FF0000;

    // Reset CFGR2 register
    RCC->CFGR2 = 0x00000000;
#elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) 
    // Disable all interrupts and clear pending bits
    RCC->CIR = 0x009F0000;

    // Reset CFGR2 register
    RCC->CFGR2 = 0x00000000;
#else
    // Disable all interrupts and clear pending bits
    RCC->CIR = 0x009F0000;
#endif

    init_clocks();

//  NVIC_SetPriorityGrouping(7);	// no preemption, 4 bit of subprio
    NVIC_SetPriorityGrouping(6);	// 1 bit preemption, 3 bit of subprio
//  NVIC_SetPriorityGrouping(5);	// 2 bit preemption, 2 bit of subprio
//  NVIC_SetPriorityGrouping(4);	// 3 bit preemption, 1 bit of subprio
//  NVIC_SetPriorityGrouping(3);	// 4 bit preemption, 0 bit of subprio
}
